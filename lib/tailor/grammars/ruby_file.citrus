grammar RubyFile
	include RubyString
	include RubyComment

	# TODO: Get rid of lines rule
	rule file_content
		lines {
			##
			# Finds all errors for the given rule.
			# 
			# @param [Symbol] rule The rule to find errors for.  This rule must have
			# 	the method #malformed? defined for it.
			# @return [Array] The list of errors found for the given rule.  If no
			# 	errors were found, an empty Array is returned.
			def errors_for_rule(rule)
				errors = []
				matches = find(rule.to_sym)
				matches.each do |match|
					errors << match if match.malformed?
				end

				errors
			end

			##
			# Collects all style errors in to a single Array.
			# 
			# @return [Array] All style errors.  If none are found, the Array will
			# 	be empty.
			def error_collection
				collection = []
				rules_with_errors = [:string, :hard_tab, :line]

				rules_with_errors.each do |rule|
					errors = errors_for_rule(rule)
					collection.concat(errors) unless errors.nil?
				end

				collection
			end

			def local_style_errors
				if malformed?
					errors = {}
					errors[:problem_text] = text
					errors[:summary] = summary
					
					errors
				end
			end

			##
			# Returns a list of all problems in the file.
			# 
			# @return [Array<Hash>] A list of all problems in the file, where each
			# 	element is a Hash containing info about the problem.
			def style_errors
				all_error_hashes = error_collection

				unless all_error_hashes.nil?
					errors = all_error_hashes.map do |s|
						error = {}
						error[:line] = line_number_of(s)
						error[:problem_text] = s.local_style_errors[:problem_text]
						error[:summary] = s.local_style_errors[:summary]
						error
					end
				end
			end

			##
			# Returns a list of the offsets of all newlines in the file.  When we
			# know at which point the newlines occur, then we can compare matches to
			# elements in this array to then determine which line of the file the
			# match occurs in.
			# 
			# @return [Array<Fixnum>] The array of offsets of all newline matches.
			def newline_offsets
				newline_chars = find(:newline)
				newline_offsets = newline_chars.map do |eol|
					eol.offset
				end

				newline_offsets
			end

			##
			# Returns the line number a given match occurs on.
			# 
			# @param [Citrus::Match] The Match to find the line number for.
			# @return [Fixnum] The line number of the match provided.
			def line_number_of match
				newline_offsets.each_with_index do |eol_offset, index|
					if match.offset > eol_offset
						return(index + 2) if newline_offsets.last == eol_offset
					else
						return(index + 1)
					end
				end
			end
		}
	end

	rule lines
		(line (newline line)*) {
			def malformed?
				if line.malformed?
					return true
				end

				false
			end
		}
	end

	rule line
		((hard_tab | string | comment | rest_of_line)* &newline?) {
			def malformed?
				length = text.length
				
				length > 80 ? true : false
			end

			def local_style_errors
				if malformed?
					errors = {}
					errors[:problem_text] = text
					errors[:summary] = "Line is >80 characters (#{text.length})"

					errors
				end
			end
		}
	end

	rule rest_of_line
		[^\r\n] | [^\n]
	end

	rule newline
		[\r\n] | [\n]
	end

	rule hard_tab
		[\t] {
			def malformed?; true; end;

			def local_style_errors
				if malformed?
					errors = {}
					errors[:problem_text] = text
					errors[:summary] = "[Spacing]  Line contains hard tabs"
					
					errors
				end
			end
		}
	end
end
